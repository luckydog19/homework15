##一.JVM
###1.简介
JVM 是Java虚拟机，是一个虚构出来的计算机，是通过在实际计算机上仿真模拟各种计算功能来实现的，Java语言跨平台就是依赖于JVM来实现的。通过Java语言编写的Java文件编译成class文件，class文件放入JVM中转义机器码，让机器执行，通常我们所说的Java程序一次编译到处运行正是因为有JVM作为解释器进行的。
###2.内部结构
JVM内部主要由三部分构成：
- 类加载器
每个Java虚拟机都有一个类加载器系统，负责加载成俗中类和接口，并赋予唯一名称。
- 运行时数据区
运行数据区主要包含了方法区、堆、虚拟机栈、本地方法栈、程序计数器
1）方法区：当JVM的类装载器加载.class文件，并进行解析，把解析的类型信息放入方法区
2）堆：虚拟机中只有一个堆，所有的线程都共享它，主要是存放程序运行时创建的对象。
3）虚拟机栈：存放的为当前线程中局部基本类型的变量、部分的返回结果以及stack frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址。
4）本地方法栈：用于支持native方法的执行，存储每个native方法调用的状态。
5）程序计数器：一个线程都有它自己的程序计数器，也是该线程启动时创建，存储着下一条被执行指令的地址。
- 执行引擎
负责执行被加载类中包含的指令。主要执行技术有：解释、即时编译、自适应优化、芯片级直接执行；解释属于第一代JVM，即使编译JIT属于第二代JVM，自适应优化(Sun的HotspotJVM采用这种技术)吸收第一代JVM和第二代JVM的经验，采用结合两种的方式。

![](D:\Java\geekuniversity\images\jvm.png)

##二.NIO
###1.定义
NIO是从jdk1.4提出的，本意是New IO（相对于传统的IO），也叫 No Blocked IO（只相对于网络IO），它的出现弥补传统IO的不足，提出了更加高效的方式。
- NIO对于网络IO而言:
jdk1.4：采用了基于select/poll的多路复用IO模型。
jdk1.5及以上：采用了基于epoll的多路复用IO模型。
- NIO对于文件IO而言：
NIO对基于文件的IO还是阻塞模型的IO。只有基于网络IO才是非阻塞的。
###2.NIO特性
关于NIO特性有以下几点认识
- 基于通道（Channel）和缓冲区（Buffer）操作
（1）通道（Channel）：一个新的、原始的IO抽象。
（2）缓冲区支持（Buffer）：为所有的原始类型提供缓冲区支持。也就是说NIO是强制基于通道和缓冲区操作的。
（3）具体操作：数据从通道读到缓冲区，数据从缓冲区写入通道（用户进程角度）。
- 非阻塞（针对网络IO）
（1）提供多路复用、非阻塞的IO操作，即当前线程从通道读取数组到缓冲区时，或者把缓冲区数据写入到通道时，线程依然可以进行其他事情。
- 选择器（selectors）（针对网络IO）
（1）用户监听多个通道的事件，如：连接打开，数据到达等，单个线程可监听多个数据通道。
- 其他
（1）提供字符集编码、解码解决方案：java.nio.Charset。
（2）支持锁和内存映射文件的文件访问接口。
###5.核心组件
- 通道（Channel）：Java NIO的数据来源，可以是网络，也可以是本地磁盘。表示打开到IO设备（文件、套接字）的连接。
- 缓冲区（Buffer）：数据读写的中转区。用于容纳数据。
- 选择器（Selectors）：异步IO的核心类，可以实现异步非阻塞IO，一个Selectors可以管理多个通道Channel。
###6.IO与NIO的区别
| 类型   | 面向操作域 | 数据处理 | IO阻塞/非阻塞（基于网络IO） |
|--------|--------|--------|--------|
|JAVA IO |可以面向缓冲区，也可以直接面向数据源，使用流进行传输 | 没有缓冲区的话是直接读取字节或者字符，并且无法前后移动数据流中的数据  |   阻塞，当一个线程在读/写时，当数据完全被读取/写入或者数据没有准备好时线程不做其他任务，只能一直阻塞等待，直到数据准备好后才继续 |
|JAVA NIO|强制通道和缓冲区       | 先读到缓冲区，并且可以前后移动数据流中的数据  | 非阻塞，当一个线程在读/写时，当数据完全被读取/写入或者数据没有准备好时，线程可以做其他任务（控制其他通道） ，直到数据准备好后在切换回原来通道继续执行读/写操作  |
##三.并发编程
并发编程其实是一种解耦合的策略，它帮助我们把做什么（目标）和什么时候做（时机）分开。这样做可以明显改进应用程序的吞吐量（获得更多的CPU调度时间）和结构（程序有多个部分在协同工作）。
- Java多线程
（1）Thread类
 | 重要属性和方法 | 说明 |
|--------|--------|
| volatile String name;    |线程名称 – 诊断分析使用|
| boolean daemon = false;  |后台守护线程标志 – 决定JVM优雅关闭|
| Runnable target;    |任务(只能通过构造函数传入)|
| synchronized void start()|【协作】启动新线程并自动执行|
| void join()   |【协作】等待某个线程执行完毕（来汇合）|
| static native Thread currentThread();   |静态方法: 获取当前线程信息|
| static native void sleep(long millis);  |静态方法: 线程睡眠并让出CPU时间片|
（2）wait&notify
 | Object#方法 | 说明 |
|--------|--------|
| void wait()  |放弃锁+等待0ms+尝试获取锁;|
| void wait(long timeout, int nanos)  |放弃锁 + wait + 到时间自动唤醒/中途唤醒(精度: nanos>0则 timeout++)|
| native void wait(long timeout);  |放弃锁+ wait + 到时间自动唤醒/中途被唤醒(唤醒之后需要自动获取锁)|
| native void notify();  |发送信号通知1个等待线程|
| native void notifyAll(); |发送信号通知所有等待线程|
（3）Thread状态
![](D:\Java\geekuniversity\images\Thread.png)
- 线程安全
多个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件,导致竞态条件发生的代码区称作临界区,不进行恰当的控制，会导致线程安全问题。
（1）原子性：原子操作，注意跟事务 ACID 里原子性的区别与联系对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
（2）可见性：对于可见性，Java 提供了 volatile 关键字来保证可见性。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。另外，通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。
（3）有序性：Java 允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。可以通过 volatile 关键字来保证一定的“有序性”（synchronized 和 Lock也可以）。
- 线程池原理与应用
（1）创建线程池的方法
   a.newSingleThreadExecutor
创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的
线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
   b.newFixedThreadPool
创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到
最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
   c.newCachedThreadPool
创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，
那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。
此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
   d.newScheduledThreadPool
创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求
（2）创建固定线程池的经验
不是越大越好，太小肯定也不好：
假设核心数为 N
 a.如果是 CPU 密集型应用，则线程池大小设置为 N 或 N+1
 b.如果是 IO 密集型应用，则线程池大小设置为 2N 或 2N+2
##四.Spring和ORM框架
- Spring框架设计
(1)框架是基于一组类库或工具，在特定领域里根据一定的规则组合成的、开放性的骨架。
框架具有如下特性：
a）支撑性+扩展性：框架不解决具体的业务功能问题，我们可以在框架的基础上添加各种
具体的业务功能、定制特性，从而形成具体的业务应用系统。
b）聚合性+约束性：框架是多种技术点的按照一定规则的聚合体。我们采用了某种框架也
就意味着做出了技术选型的取舍。在很多种可能的技术组合里确定了一种具体的实现方式
，后续的其他工作都会从这些技术出发，也需要遵循这些规则，所以框架本身影响到研发
过程里的方方面面
(2)Spring framework 6大模块
   a)Core：Bean/Context/AOP
   b)Testing：Mock/TestContext
   c)DataAccess: Tx/JDBC/ORM
   d)Spring MVC/WebFlux: web
   e)Integration: remoting/JMS/WS
   f)Languages: Kotlin/Groovy

![](D:\Java\geekuniversity\images\Spring.png)
- Spring AOP
（1）AOP-面向切面编程
Spring早期版本的核心功能: 管理对象生命周期与对象装配。
为了实现管理和装配，一个自然而然的想法就是，加一个中间层代理（字节码增强）来
实现所有对象的托管。
（2）IoC-控制反转
也称为DI（Dependency Injection）依赖注入。对象装配思路的改进。
从对象A直接引用和操作对象B，变成对象A里指需要依赖一个接口IB，系统启动和装配
阶段，把IB接口的实例对象注入到对象A，这样A就不需要依赖一个IB接口的具体实现，
也就是类B。
![](D:\Java\geekuniversity\images\Soap.png)
- Spring Dean
（1）Bean的加载过程及生命周期
![](D:\Java\geekuniversity\images\SpringBean.png)

##五.MySQL数据库和SQL
- SQL语言
1.数据查询语言（DQL: Data Query Language）：其语句，也称为“数据检索语句”，用以从表中获得数据，确
定数据怎样在应用程序给出。保留字 SELECT 是 DQL（也是所有 SQL）用得最多的动词，其他 DQL 常用的保留字
有 WHERE，ORDER BY，GROUP BY 和 HAVING。这些 DQL 保留字常与其它类型的 SQL 语句一起使用。
2.数据操作语言（DML：Data Manipulation Language）：其语句包括动词 INSERT、UPDATE 和 DELETE。它
们分别用于添加、修改和删除。
3.事务控制语言（TCL）：它的语句能确保被 DML 语句影响的表的所有行及时得以更新。包括COMMIT（提交）
命令、SAVEPOINT（保存点）命令、ROLLBACK（回滚）命令。
4.数据控制语言（DCL）：它的语句通过 GRANT 或 REVOKE 实现权限控制，确定单个用户和用户组对数据库对象
的访问。某些 RDBMS 可用 GRANT 或 REVOKE 控制对表单个列的访问。
5.数据定义语言（DDL）：其语句包括动词 CREATE,ALTER 和 DROP。在数据库中创建新表或修改、删除表
（CREAT TABLE 或 DROP TABLE）；为表加入索引等。
6.指针控制语言（CCL）：它的语句，像 DECLARE CURSOR，FETCH INTO 和 UPDATE WHERE CURRENT 用于对
一个或多个表单独行的操作
- MySQL数据库架构图
![](D:\Java\geekuniversity\images\MySql.png)
- MySql配置优化
1.连接请求的变量
（1）max_connections
（2）back_log
（3）wait_timeout和interative_timeout
2.缓冲区变量
（1）key_buffer_size
（2）query_cache_size（查询缓存简称 QC)
（3）max_connect_errors
（4）sort_buffer_size
（5）max_allowed_packet=32M
（6）join_buffer_size=2M
（7）thread_cache_size=300
3.配置 Innodb 的几个变量
（1）key_buffer_size
（2）query_cache_size（查询缓存简称 QC)
（3）max_connect_errors
（4）sort_buffer_size
（5）max_allowed_packet=32M
（6）join_buffer_size=2M
（7）thread_cache_size=300
##六.分库分表
- 数据库垂直拆分
1.拆库
将一个数据库，拆分成多个提供不同业务数据处理能力的数据库。
2.拆表
垂直拆分（拆表）：如果单表数据量过大，还可能需要对单表进行拆分。
3.垂直拆分优点
（1）单库（单表）变小，便于管理和维护
（2）对性能和容量有提升作用
（3）改造后，系统和数据复杂度降低
（4）可以作为微服务改造的基础
4.垂直拆分缺点
（1）库变多，管理变复杂
（2）对业务系统有较强的侵入性
（3）改造过程复杂，容易出故障
（4）拆分到一定程度就无法继续拆分
- 数据库水平拆分
1.水平拆分（按主键分库分表）：水平拆分就是直接对数据进行分片，有分库和分表两个具体方式，但是都只是
降低单个节点数据量，但不改变数据本身的结构。这样对业务系统本身的代码逻辑来说，就不需要做特别大的
改动，甚至可以基于一些中间件做到透明
2.水平拆分（按时间分库分表）：很多时候，我们的数据是有时间属性的，所以自然可以按照时间维度来拆
分。比如当前数据表和历史数据表，甚至按季度，按月，按天来划分不同的表。这样我们按照时间维度来
查询数据时，就可以直接定位到当前的这个子表。更详细的分析参考下一个小节。
3.强制按条件指定分库分表：比如配置好某些用户的数据进入单独的库表，其他数据默认处理。
4.自定义方式分库分表：指定某些条件的数据进入到某些库或表。
5.水平拆分有点：
（1）解决容量问题
（2）比垂直拆分对系统影响小
（3）部分提升性能和稳定性
6.水平拆分缺点
（1）集群规模大，管理复杂
（2）复杂 SQL 支持问题（业务侵入性、性能）
（3）数据迁移问题
（4）一致性问题
##七.RPC和微服务
- RPC原理
RPC 的简化版原理如下图。
核心是代理机制。
1.本地代理存根: Stub
2.本地序列化反序列化
3.网络通信
4.远程序列化反序列化
5.远程服务存根: Skeleton
6.调用实际业务服务
7.原路返回服务结果
8.返回给本地调用方
![](D:\Java\geekuniversity\images\RPC.png)
整体架构图
![](D:\Java\geekuniversity\images\RPC1.png)
- 从 RPC 走向服务化->微服务架构
具体的分布式业务场景里，除了能够调用远程方法，我们还需要考虑
1、多个相同服务如何管理？ ==> 集群/分组/版本 => 分布式与集群
2、服务的注册发现机制？ ==> 注册中心/注册/发现
3、如何负载均衡，路由等集群功能？ ==> 路由/负载均衡
4、熔断，限流等治理能力。 ==> 过滤/流控
5、心跳，重试等策略。
6、高可用、监控、性能等等。

##八.分布式缓存
- 缓存穿透
1.问题：大量并发查询不存在的 KEY，导致都直接将压力透传到数据库。
2.解决：
（1）缓存空值的 KEY，这样第一次不存在也会被加载会记录，下次拿到有这个 KEY。
（2）Bloom 过滤或 RoaringBitmap 判断 KEY 是否存在。
（3）完全以缓存为准，使用 延迟异步加载 的策略2，这样就不会触发更新。
- 缓存击穿
1.问题：某个 KEY 失效的时候，正好有大量并发请求访问这个 KEY。
2.解决：
（1）KEY 的更新操作添加全局互斥锁。
（2）完全以缓存为准，使用 延迟异步加载 的策略2，这样就不会触发更新。
- 缓存雪崩
1.问题：当某一时刻发生大规模的缓存失效的情况，会有大量的请求进来直接打到数据库，导致数据
库压力过大甚至宕机。
2.解决：
（1）更新策略在时间上做到比较均匀。
（2）使用的热数据尽量分散到不同的机器上。
（3）多台机器做主从复制或者多副本，实现高可用。
（4）实现熔断限流机制，对系统进行负载能力控制。
![](D:\Java\geekuniversity\images\fenbushi.png)
##九.分布式消息队列
- 消息模式与消息协议
1.常见的有两种消息模式：
（1）点对点：PTP，Point-To-Point对应于Queue
 ![](D:\Java\geekuniversity\images\topic1.png)
（2）发布订阅：PubSub，Publish-Subscribe，对应于 Topic
![](D:\Java\geekuniversity\images\topic2.png)
